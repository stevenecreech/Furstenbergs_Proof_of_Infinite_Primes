import Mathlib

open Set

namespace Furstenberg

-- Basic open set: arithmetic progression A_{a,b} = {an + b | n ∈ ℤ}
@[reducible]
def arithSeq (a : ℤ) (b : ℤ) : Set ℤ :=
  { x | ∃ n : ℤ, x = a * n + b }

lemma arithSeq_infinite (a b : ℤ) (ha : a ≠ 0) : ¬(arithSeq a b).Finite := by
  -- Define f(n) = a * n + b
  let f : ℤ → ℤ := fun n => a * n + b

  -- The range of f is exactly arithSeq a b
  have hrange : Set.range f = arithSeq a b := by
    ext x
    simp only [arithSeq, Set.mem_range, Set.mem_setOf_eq]
    constructor
    · rintro ⟨n, rfl⟩; exact ⟨n, rfl⟩
    · rintro ⟨n, rfl⟩; exact ⟨n, rfl⟩

  -- f is injective because a ≠ 0
  have hinj : Function.Injective f := by
    intros m n h
    simp [f] at h
    rcases h with h | h
    exact h
    contradiction
  -- The image of an injective function on an infinite domain is infinite
  have : (Set.range f).Infinite := by
    exact infinite_range_of_injective hinj
  rw [hrange] at this
  exact this



-- Show that the arithSeqs with a ≠ 0 form a basis
def FurstenbergBasis : Set (Set ℤ) :=
  { U | ∃ (a : ℤ) (b : ℤ), a ≠ 0 ∧ U = arithSeq a b }

-- Define the topology generated by this basis
def furstenbergTopology : TopologicalSpace ℤ :=
  TopologicalSpace.generateFrom FurstenbergBasis

-- Declare instance so ℤ is now a topological space with this topology
instance : TopologicalSpace ℤ := furstenbergTopology

lemma FurstenbergBasis_is_basis : TopologicalSpace.IsTopologicalBasis FurstenbergBasis where
  exists_subset_inter := by
    intro U1 U1Basis U2 U2Basis N N_in_intersection

    obtain ⟨a1, b1, ha1, rfl⟩ := U1Basis
    obtain ⟨a2, b2, ha2, rfl⟩ := U2Basis
    rcases N_in_intersection with ⟨N_in_U1, N_in_U2⟩
    rcases N_in_U1 with ⟨n1, hN1⟩
    rcases N_in_U2 with ⟨n2, hN2⟩
    -- So N = a1 * n1 + b1 = a2 * n2 + b2

    -- Define new U1' = arithSeq a1 N
    let U1' := arithSeq a1 N
    let U2' := arithSeq a2 N

    -- We'll work with U1' and U2', since N ∈ both and U1' ⊆ U1, U2' ⊆ U2
    -- In the next step, we’ll construct a common refinement from them
    -- Recall:
-- U1 = arithSeq a1 b1, U1' = arithSeq a1 N
-- and N ∈ U1, so ∃ n1, N = a1 * n1 + b1

    -- We'll now prove: arithSeq a1 N = arithSeq a1 b1
    have U1'_eq_U1 : arithSeq a1 N = arithSeq a1 b1 := by
      ext x
      constructor
      · intro hx
        rcases hx with ⟨n, rfl⟩
        -- x = a1 * n + N = a1 * n + (a1 * n1 + b1) = a1 * (n + n1) + b1
        use n + n1
        rw [hN1]
        ring
      · intro hx
        rcases hx with ⟨n, rfl⟩
        -- x = a1 * n + b1 = a1 * n + (N - a1 * n1) = a1 * (n - n1) + N
        use n - n1
        rw[hN1]
        ring
    -- Same argument for U2'
    have U2'_eq_U2 : arithSeq a2 N = arithSeq a2 b2 := by
      ext x
      constructor
      · intro hx
        rcases hx with ⟨n, rfl⟩
        use n + n2
        rw [hN2]
        ring
      · intro hx
        rcases hx with ⟨n, rfl⟩
        use n - n2
        rw [hN2]
        ring
    let a3 := a1.lcm a2
    have : a1.lcm a2 ≠ 0 := by
      apply Int.lcm_ne_zero
      exact ha1
      exact ha2
    have a3neq0 : a3 ≠ 0 := by
      exact this
    have a3diva1 : ∃ a3', a3 = a1 * a3' := by
      refine dvd_def.mp ?_
      exact Int.dvd_lcm_left a1 a2
    obtain ⟨a3',ha3'⟩ := a3diva1
    have a3diva2 : ∃ a3'', a3 = a2 * a3'' := by
      refine dvd_def.mp ?_
      exact Int.dvd_lcm_right a1 a2
    obtain ⟨a3'',ha3''⟩ := a3diva2

    let arith_a3N := arithSeq a3 N
    have N_in_arith_a3N : (N : ℤ) ∈ arith_a3N := by
      unfold arith_a3N
      unfold arithSeq
      dsimp
      use 0
      simp
    have arith_a3N_is_basis : arith_a3N ∈ FurstenbergBasis := by
      use a3, N
      constructor
      · exact Int.ofNat_ne_zero.mpr this
      · rfl
    use arith_a3N
    constructor
    · exact arith_a3N_is_basis
    · constructor
      · exact N_in_arith_a3N
      · simp
        constructor
        · rw[← U1'_eq_U1]
          intro x hx
          obtain ⟨n, hn⟩ := hx
          rw [hn]
          unfold arithSeq
          use (n * a3')
          ring
          rw[ha3']
          ring
        · rw[← U2'_eq_U2]
          intro x hx
          obtain ⟨n, hn⟩ := hx
          rw [hn]
          unfold arithSeq
          use (n * a3'')
          ring
          rw[ha3'']
          ring

  sUnion_eq := by
    ext z
    constructor
    · intro _
      trivial
    · intro _
      use arithSeq 1 z
      constructor
      · use 1, z
        exact ⟨by norm_num, rfl⟩
      · use 0
        simp [arithSeq]

  eq_generateFrom := by
    rfl

-- Lemma: Every nonempty open set is infinite
lemma open_nonempty_infinite (U : Set ℤ) (hU : IsOpen U) (hne : U.Nonempty) :
    ¬U.Finite := by
  intro hfin
  obtain ⟨z, hz⟩ := hne
  -- Since U is open, and the topology is generated by arithmetic sequences,
  -- there exists a basis set B ⊆ U such that z ∈ B
  rw [isOpen_iff_mem_nhds] at hU
  specialize hU z hz
  have basis_property : TopologicalSpace.IsTopologicalBasis FurstenbergBasis := FurstenbergBasis_is_basis
  obtain ⟨B, B_in, hzB, hBU⟩ := basis_property.mem_nhds_iff.mp hU
  obtain ⟨a, b, ha, rfl⟩ := B_in  -- B = arithSeq a b, a ≠ 0
  have hinf : ¬(arithSeq a b).Finite := arithSeq_infinite a b ha
  exact hinf (hfin.subset hBU)

lemma finite_nonempty_not_open (S : Set ℤ) (hfin : S.Finite) (hne : S.Nonempty) :
    ¬IsOpen S := by
  intro hop
  exact open_nonempty_infinite S hop hne hfin


lemma arithSeq_is_clopen (a b : ℤ) (ha : a ≠ 0) :
    IsOpen (arithSeq a b) ∧ IsClosed (arithSeq a b) := by
  -- Open: since arithSeq a b ∈ FurstenbergBasis
  have hopen : IsOpen (arithSeq a b) := by
    apply TopologicalSpace.IsTopologicalBasis.isOpen
    exact FurstenbergBasis_is_basis
    use a, b

  -- Closed: complement is a finite union of open sets
  let A := Finset.range (Int.natAbs a)
  let rest : Set ℤ := ⋃ j ∈ A.filter (fun j ↦ j ≠ (b % a).natAbs), arithSeq a (b + j)


  have hcompl : arithSeq a b =
  univ \ ⋃ j ∈ A.filter (fun j ↦ j ≠ (b % a).natAbs), arithSeq a (b + j) := by
    ext z
    simp only [arithSeq, mem_diff, mem_univ, mem_iUnion, mem_setOf_eq, Finset.mem_filter,
                Finset.mem_range, not_exists, not_and, not_not]
    sorry

  have hclosed : IsClosed (arithSeq a b) := by
    rw [hcompl]
    have hopen_compl : IsOpen (⋃ j ∈ A.filter (fun j ↦ j ≠ (b % a).natAbs), arithSeq a (b + j)) := by
      apply isOpen_iUnion
      intro i
      refine isOpen_iUnion ?_
      intro hi
      refine TopologicalSpace.isOpen_generateFrom_of_mem ?_
      sorry
    refine IsClosed.sdiff ?_ hopen_compl
    exact isClosed_univ
  exact ⟨hopen, hclosed⟩

def primes : Set ℤ := { p | Nat.Prime p.natAbs }

lemma Z_diff_pm1_eq_union_primes :
    univ \ { -1, 1 } = ⋃ p ∈ primes, arithSeq p 0 := by
  ext z
  simp only [mem_diff, mem_univ, true_and, mem_singleton_iff, mem_iUnion, primes, arithSeq, mem_setOf_eq]
  constructor
  · intro hz
    -- Case: z ≠ ±1 ⇒ ∃ prime p such that p ∣ z
    -- Use the fact that every integer ≠ ±1 has a prime divisor
    by_cases hzero : z = 0
    · -- z = 0 ⇒ divisible by any prime
      use 2
      constructor
      · use 0
        simp
        exact hzero
      · exact Nat.properDivisors_eq_singleton_one_iff_prime.mp rfl
    · -- z ≠ 0 ⇒ has nontrivial prime factor
      have : z ≠ 1 ∧ z ≠ -1 := by
        simp at hz
        exact id (And.symm hz)
      have zneq1 : z ≠ 1 := this.left
      have nzeqm1 : z ≠ -1 := this.right
      have hznatAbs_ne_one : z.natAbs ≠ 1 := by
        intro h
        have hz_abs : z = 1 ∨ z = -1 := by
          rw [Int.natAbs_eq_iff] at h
          exact h
        cases hz_abs
        · contradiction
        · contradiction
      have : ∃ p, Nat.Prime p ∧ p ∣ z.natAbs := by
        exact Nat.exists_prime_and_dvd hznatAbs_ne_one
      obtain ⟨p, pPrime, pdvdz⟩:= this
      use p
      simp
      constructor
      · exact pPrime
      · obtain ⟨n, hn⟩ := pdvdz


        sorry
        match le_or_gt 0 z with
        | Or.inl hz_nonneg =>
          -- Handle the case where 0 ≤ z
          use n
          have : z = p * n := by
            match Int.natAbs_eq z with
            | Or.inl h => rw [h, hn]
            | Or.inr h => rw [h, hn]

          sorry
        | Or.inr hz_neg =>
          -- Handle the case where z < 0
          sorry
        sorry



end Furstenberg
