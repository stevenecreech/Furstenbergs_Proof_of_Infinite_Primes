import Mathlib
open Set

namespace Furstenberg

-- Basic open set: arithmetic progression A_{a,b} = {an + b | n ∈ ℤ}
@[reducible]
def arithSeq (a : ℤ) (b : ℤ) : Set ℤ :=
  { x | ∃ n : ℤ, x = a * n + b }

lemma arithSeq_infinite (a b : ℤ) (ha : a ≠ 0) : ¬(arithSeq a b).Finite := by
  -- Define f(n) = a * n + b
  let f : ℤ → ℤ := fun n => a * n + b

  -- The range of f is exactly arithSeq a b
  have hrange : Set.range f = arithSeq a b := by
    ext x
    simp only [arithSeq, Set.mem_range, Set.mem_setOf_eq]
    constructor
    · rintro ⟨n, rfl⟩; exact ⟨n, rfl⟩
    · rintro ⟨n, rfl⟩; exact ⟨n, rfl⟩

  -- f is injective because a ≠ 0
  have hinj : Function.Injective f := by
    intros m n h
    simp [f] at h
    rcases h with h | h
    exact h
    contradiction
  -- The image of an injective function on an infinite domain is infinite
  have : (Set.range f).Infinite := by
    exact infinite_range_of_injective hinj
  rw [hrange] at this
  exact this



-- Show that the arithSeqs with a ≠ 0 form a basis
def FurstenbergBasis : Set (Set ℤ) :=
  { U | ∃ (a : ℤ) (b : ℤ), a ≠ 0 ∧ U = arithSeq a b }

-- Define the topology generated by this basis
def furstenbergTopology : TopologicalSpace ℤ :=
  TopologicalSpace.generateFrom FurstenbergBasis

-- Declare instance so ℤ is now a topological space with this topology
instance : TopologicalSpace ℤ := furstenbergTopology

lemma FurstenbergBasis_is_basis : TopologicalSpace.IsTopologicalBasis FurstenbergBasis where
  exists_subset_inter := by
    intro U1 U1Basis U2 U2Basis N N_in_intersection

    obtain ⟨a1, b1, ha1, rfl⟩ := U1Basis
    obtain ⟨a2, b2, ha2, rfl⟩ := U2Basis
    rcases N_in_intersection with ⟨N_in_U1, N_in_U2⟩
    rcases N_in_U1 with ⟨n1, hN1⟩
    rcases N_in_U2 with ⟨n2, hN2⟩
    -- So N = a1 * n1 + b1 = a2 * n2 + b2

    -- Define new U1' = arithSeq a1 N
    let U1' := arithSeq a1 N
    let U2' := arithSeq a2 N

    -- We'll work with U1' and U2', since N ∈ both and U1' ⊆ U1, U2' ⊆ U2
    -- In the next step, we’ll construct a common refinement from them
    -- Recall:
-- U1 = arithSeq a1 b1, U1' = arithSeq a1 N
-- and N ∈ U1, so ∃ n1, N = a1 * n1 + b1

    -- We'll now prove: arithSeq a1 N = arithSeq a1 b1
    have U1'_eq_U1 : arithSeq a1 N = arithSeq a1 b1 := by
      ext x
      constructor
      · intro hx
        rcases hx with ⟨n, rfl⟩
        -- x = a1 * n + N = a1 * n + (a1 * n1 + b1) = a1 * (n + n1) + b1
        use n + n1
        rw [hN1]
        ring
      · intro hx
        rcases hx with ⟨n, rfl⟩
        -- x = a1 * n + b1 = a1 * n + (N - a1 * n1) = a1 * (n - n1) + N
        use n - n1
        rw[hN1]
        ring
    -- Same argument for U2'
    have U2'_eq_U2 : arithSeq a2 N = arithSeq a2 b2 := by
      ext x
      constructor
      · intro hx
        rcases hx with ⟨n, rfl⟩
        use n + n2
        rw [hN2]
        ring
      · intro hx
        rcases hx with ⟨n, rfl⟩
        use n - n2
        rw [hN2]
        ring
    let a3 := a1.lcm a2
    have : a1.lcm a2 ≠ 0 := by
      apply Int.lcm_ne_zero
      exact ha1
      exact ha2
    have a3neq0 : a3 ≠ 0 := by
      exact this
    have a3diva1 : ∃ a3', a3 = a1 * a3' := by
      refine dvd_def.mp ?_
      exact Int.dvd_lcm_left a1 a2
    obtain ⟨a3',ha3'⟩ := a3diva1
    have a3diva2 : ∃ a3'', a3 = a2 * a3'' := by
      refine dvd_def.mp ?_
      exact Int.dvd_lcm_right a1 a2
    obtain ⟨a3'',ha3''⟩ := a3diva2

    let arith_a3N := arithSeq a3 N
    have N_in_arith_a3N : (N : ℤ) ∈ arith_a3N := by
      unfold arith_a3N
      unfold arithSeq
      dsimp
      use 0
      simp
    have arith_a3N_is_basis : arith_a3N ∈ FurstenbergBasis := by
      use a3, N
      constructor
      · exact Int.ofNat_ne_zero.mpr this
      · rfl
    use arith_a3N
    constructor
    · exact arith_a3N_is_basis
    · constructor
      · exact N_in_arith_a3N
      · simp
        constructor
        · rw[← U1'_eq_U1]
          intro x hx
          obtain ⟨n, hn⟩ := hx
          rw [hn]
          unfold arithSeq
          use (n * a3')
          ring
          rw[ha3']
          ring
        · rw[← U2'_eq_U2]
          intro x hx
          obtain ⟨n, hn⟩ := hx
          rw [hn]
          unfold arithSeq
          use (n * a3'')
          ring
          rw[ha3'']
          ring

  sUnion_eq := by
    ext z
    constructor
    · intro _
      trivial
    · intro _
      use arithSeq 1 z
      constructor
      · use 1, z
        exact ⟨by norm_num, rfl⟩
      · use 0
        simp [arithSeq]

  eq_generateFrom := by
    rfl

-- Lemma: Every nonempty open set is infinite
lemma open_nonempty_infinite (U : Set ℤ) (hU : IsOpen U) (hne : U.Nonempty) :
    ¬U.Finite := by
  intro hfin
  obtain ⟨z, hz⟩ := hne
  -- Since U is open, and the topology is generated by arithmetic sequences,
  -- there exists a basis set B ⊆ U such that z ∈ B
  rw [isOpen_iff_mem_nhds] at hU
  specialize hU z hz
  have basis_property : TopologicalSpace.IsTopologicalBasis FurstenbergBasis := FurstenbergBasis_is_basis
  obtain ⟨B, B_in, hzB, hBU⟩ := basis_property.mem_nhds_iff.mp hU
  obtain ⟨a, b, ha, rfl⟩ := B_in  -- B = arithSeq a b, a ≠ 0
  have hinf : ¬(arithSeq a b).Finite := arithSeq_infinite a b ha
  exact hinf (hfin.subset hBU)

lemma finite_nonempty_not_open (S : Set ℤ) (hfin : S.Finite) (hne : S.Nonempty) :
    ¬IsOpen S := by
  intro hop
  exact open_nonempty_infinite S hop hne hfin


lemma arithSeq_is_clopen (a b : ℤ) (ha : a ≠ 0) :
    IsOpen (arithSeq a b) ∧ IsClosed (arithSeq a b) := by
  -- Open: since arithSeq a b ∈ FurstenbergBasis
  have hopen : IsOpen (arithSeq a b) := by
    apply TopologicalSpace.IsTopologicalBasis.isOpen
    exact FurstenbergBasis_is_basis
    use a, b

  -- Closed: complement is a finite union of open sets
  let A : Finset ℕ := Finset.Ico 1 a.natAbs
  let rest := ⋃ j ∈ A, arithSeq a (b + j)
  have hcompl : arithSeq a b = univ \ rest := by
    ext z
    simp only [arithSeq, mem_diff, mem_univ, mem_iUnion, mem_setOf_eq]
    constructor
    · rintro ⟨n, rfl⟩
      constructor
      · exact trivial
      · intro h
        unfold rest at h
        simp only [Set.mem_iUnion] at h
        obtain ⟨j, hjA, n'⟩ := h
        obtain ⟨k, hk⟩ := n'
        have h_eq : a * n + b = a * k + (b + ↑j) := hk
        have h_sub_b : a * n = a * k + ↑j := by linarith [h_eq]
        have h_divides : a * (n - k) = ↑j := by linarith [h_sub_b]
        have a_dvd_j : a ∣ ↑j := ⟨n - k, by linarith⟩
        -- From j ∈ A = Finset.Ico 1 a.natAbs, we have 1 ≤ j < a.natAbs
        have j_ge_1 : 1 ≤ j := Finset.mem_Ico.mp hjA |>.left
        have j_lt_a : j < a.natAbs := Finset.mem_Ico.mp hjA |>.right
        -- Therefore j ≠ 0, so ↑j.natAbs = j, and 0 < j < a.natAbs
        have j_pos : 0 < j := Nat.lt_of_lt_of_le zero_lt_one j_ge_1
        -- So ↑j = a * m for some m ∈ ℤ, and j = |↑j| = |a * m| ≥ |a| = a.natAbs
        obtain ⟨m, hm⟩ := a_dvd_j
        have : (a * m).natAbs = a.natAbs * m.natAbs := Int.natAbs_mul a m
        have m_dvd_j: m ∣ j := by
          use a
          rw[hm]
          ring
        have mneq0 : m ≠ 0 := by
          by_contra m0
          rw[m0] at hm
          have : j = 0 := by
            rw [mul_zero] at hm
            exact Int.ofNat_eq_zero.mp hm
          rw [hm, mul_zero] at hm
          linarith
        have mabsge1 : m.natAbs ≥ 1 := by
          refine Nat.one_le_iff_ne_zero.mpr ?_
          exact Int.natAbs_ne_zero.mpr mneq0
        rw[← hm] at this
        have jabs_lt_aabs : (↑j : ℤ).natAbs < a.natAbs := by
          exact j_lt_a
        rw[this] at jabs_lt_aabs
        have j_eq : j = a.natAbs * m.natAbs := by
          exact this
        rw [j_eq] at j_lt_a
        have h_contra := Nat.mul_le_mul_left a.natAbs mabsge1
        simp at h_contra
        linarith

    · intro h
      let q := (z - b) / a
      let r := (z - b) % a
      have h_eq : z = a * q + (b + r) := by
        have h_eq := Int.ediv_add_emod (z - b) a
        have : z = z - b + b := by
          ring
        rw[this,← h_eq]
        ring
      have hr0 : 0 ≤ r := by
        exact Int.emod_nonneg (z - b) ha
      have hrlta : r < |a| := by
        exact Int.emod_lt_abs (z - b) ha
      have : z = a * q + (b + r) := by
        have : z - b + b = z:= by
          ring
        rw[← this]
        rw[h_eq]
        ring
      by_cases hr : r = 0
      · -- Then z = a * q + b
        use q
        rw [hr, add_zero] at this
        exact this

      · -- Otherwise r ∈ {1, ..., |a| - 1} ⇒ ↑r ∈ A
        let r_nat := r.natAbs
        have hr_nat_eq : ↑r.natAbs = r := Int.natAbs_of_nonneg hr0
        have r_in_A : r_nat ∈ A := by
          rw [Finset.mem_Ico]
          constructor
          · refine Nat.one_le_iff_ne_zero.mpr ?_
            have hr : r ≠ 0 := hr
            have : r.natAbs ≠ 0 := by
              (expose_names; exact Int.natAbs_ne_zero.mpr hr_1)
            have eq1 : r_nat = r.natAbs := by
              rfl
            rw[eq1]
            exact this
          · have eq2 : r_nat = r.natAbs := rfl
            rw[eq2]
            have eq3 : a.natAbs = |a| := by
              exact Int.natCast_natAbs a
            have hr_nat_abs : ↑r.natAbs = r := Int.natAbs_of_nonneg hr0
            have eq4: ↑ ((r : ℤ).natAbs : ℤ) < ↑ a.natAbs := by
              rw[hr_nat_abs]
              exact Int.emod_lt (z - b) ha
            exact Int.ofNat_lt.mp eq4
        -- So z ∈ arithSeq a (b + ↑r_nat), contradiction
        have : z ∈ arithSeq a (b + ↑r_nat) := by
          use q
          rw [this, ← hr_nat_eq]
        have : z ∈ rest := by
          simp only [rest, mem_iUnion, Finset.mem_Ico] at r_in_A ⊢
          exact ⟨r_nat, r_in_A, this⟩

        exact absurd this h.2


  have hclosed : IsClosed (arithSeq a b) := by
    rw [hcompl]
    have hopen_compl : IsOpen rest := by
      apply isOpen_iUnion
      intro i
      refine isOpen_iUnion ?_
      intro hi
      refine TopologicalSpace.isOpen_generateFrom_of_mem ?_
      unfold FurstenbergBasis
      use a, b + ↑i
    refine IsClosed.sdiff ?_ hopen_compl
    exact isClosed_univ
  exact ⟨hopen, hclosed⟩

def primes : Set ℕ := { p | Nat.Prime p }

lemma Z_diff_pm1_eq_union_primes :
    univ \ { -1, 1 } = ⋃ p ∈ primes, arithSeq p 0 := by
  ext z
  simp only [mem_diff, mem_univ, true_and, mem_singleton_iff, mem_iUnion, primes, arithSeq, mem_setOf_eq]
  constructor
  · intro hz
    -- Case: z ≠ ±1 ⇒ ∃ prime p such that p ∣ z
    -- Use the fact that every integer ≠ ±1 has a prime divisor
    by_cases hzero : z = 0
    · -- z = 0 ⇒ divisible by any prime
      use 2
      constructor
      · use 0
        simp
        exact hzero
      · exact Nat.properDivisors_eq_singleton_one_iff_prime.mp rfl
    · -- z ≠ 0 ⇒ has nontrivial prime factor
      have : z ≠ 1 ∧ z ≠ -1 := by
        simp at hz
        exact id (And.symm hz)
      have zneq1 : z ≠ 1 := this.left
      have nzeqm1 : z ≠ -1 := this.right
      have hznatAbs_ne_one : z.natAbs ≠ 1 := by
        intro h
        have hz_abs : z = 1 ∨ z = -1 := by
          rw [Int.natAbs_eq_iff] at h
          exact h
        cases hz_abs
        · contradiction
        · contradiction
      have : ∃ p, Nat.Prime p ∧ p ∣ z.natAbs := by
        exact Nat.exists_prime_and_dvd hznatAbs_ne_one
      obtain ⟨p, pPrime, pdvdz⟩:= this
      use p
      simp
      constructor
      · exact pPrime
      · obtain ⟨n, hn⟩ := pdvdz
        cases Int.le_total 0 z with
        | inl hpos =>
          -- z ≥ 0, so z = z.natAbs
          use n
          have : z.natAbs = z := Int.natAbs_of_nonneg hpos
          rw[← this]
          exact congrArg Nat.cast hn
        | inr hneg =>
          -- z < 0, so z = -z.natAbs
          use -↑n
          have : -z.natAbs = z := Eq.symm (Int.eq_neg_natAbs_of_nonpos hneg)
          rw[← this]
          rw[hn]
          exact Eq.symm (CancelDenoms.neg_subst rfl)
  · intro h
    obtain ⟨p,hi ⟩  := h
    obtain ⟨hp, hn⟩:= hi
    simp at hn
    obtain ⟨n, eq⟩ := hn
    intro zpm1
    rcases zpm1 with zm1 | z1
    · rw[zm1] at eq
      have : -1 * -1 = -1 * p * n := by
        rw[eq]
        exact Eq.symm (Int.mul_assoc (↑p * n) (↑p) n)
      simp at this
      have h_abs : Int.natAbs (-p * n) = 1 := by
        rw[← mul_neg_one, mul_assoc, ← mul_comm n, ← mul_assoc, mul_neg_one, ← this]
        exact rfl
      have pge2 : p ≥ 2 := by
        exact Nat.Prime.two_le hp
      have : (↑p * n).natAbs = 1 := by
        rw [← Int.natAbs_neg, ← this]
        exact rfl
      -- But (↑p * n).natAbs = (↑p).natAbs * n.natAbs ≥ 2 * 1 = 2, contradiction
      have : (↑p * n).natAbs = p * n.natAbs := by
        rw [Int.natAbs_mul, Int.natAbs_natCast]
      have lower_bound : (↑p * n).natAbs ≥ 2 := by
        rw [this]
        have n_ne_zero : n ≠ 0 := by
          intro hn
          rw [hn, Int.mul_zero] at eq
          contradiction
        have pneq0 : p ≠ 0 := Nat.ne_zero_of_lt pge2
        have npneq0 : p * n ≠ 0 := by
          refine Int.mul_ne_zero_iff.mpr ?_
          constructor
          · exact Nat.cast_ne_zero.mpr pneq0
          · exact n_ne_zero
        have p_pos : p > 0 := Nat.Prime.pos hp
        have n_abs_pos : n.natAbs > 0 := by
          exact Int.natAbs_pos.mpr n_ne_zero
        have n_abs_ge1 : n.natAbs ≥ 1 := by
          exact n_abs_pos
        exact le_mul_of_le_of_one_le pge2 n_abs_pos
      -- Contradiction with h_abs : ... = 1
      linarith
    · rw[z1] at eq
      have n_ne_zero : n ≠ 0 := by
        intro hn
        rw[hn] at eq
        simp at eq
      have pge2 : p ≥ 2 := by
        exact Nat.Prime.two_le hp
      have pneq0 : p ≠ 0 := Nat.ne_zero_of_lt pge2
      have npneq0 : p * n ≠ 0 := by
        refine Int.mul_ne_zero_iff.mpr ?_
        constructor
        · exact Nat.cast_ne_zero.mpr pneq0
        · exact n_ne_zero
      have p_pos : p > 0 := Nat.Prime.pos hp
      have n_abs_pos : n.natAbs > 0 := by
        exact Int.natAbs_pos.mpr n_ne_zero
      have n_abs_ge1 : n.natAbs ≥ 1 := by
        exact n_abs_pos
      have lower_bound : (↑p * n).natAbs ≥ 2 := by
        have abs_mul : (↑p * n).natAbs = p * n.natAbs := by
          rw [Int.natAbs_mul]
          exact rfl
        rw [abs_mul]
        exact le_mul_of_le_of_one_le pge2 n_abs_pos
      rw[← eq] at lower_bound
      contradiction

-- Main theorem:
theorem infinitely_many_primes : Set.Infinite {p : ℕ | Nat.Prime p} := by
  by_contra hfin
  simp at hfin
  -- Let S be the union of all S(p, 0) for p prime
  let S := ⋃ (p ∈ {p : ℕ | Nat.Prime p}), arithSeq p 0
  -- Each arithSeq p 0 is closed
  have hclosed : ∀ p : ℕ, Nat.Prime p → IsClosed (arithSeq p 0) := by
    intros p hp
    exact (arithSeq_is_clopen (↑p) 0 (Nat.cast_ne_zero.mpr (Nat.Prime.ne_zero hp))).right
  -- Then S is a finite union of closed sets, hence closed
  have S_closed : IsClosed S := by
    have : Finite {p : ℕ | Nat.Prime p} := hfin
    exact Finite.isClosed_biUnion hfin hclosed
   -- ℤ \ S = {-1, 1} by your lemma
  have hS_eq : S = univ \ {-1, 1} := by
    rw [Z_diff_pm1_eq_union_primes]
    exact rfl
  rw [hS_eq] at S_closed
  -- So {-1, 1} is closed
  have contra := finite_nonempty_not_open {-1, 1} (by simp) (by simp)
  have pm1_open: IsOpen ({-1, 1}) := by
    refine isClosed_compl_iff.mp ?_
    have : {-1, 1}ᶜ = univ \ {-1 , 1}:= compl_eq_univ_diff {-1, 1}
    rw[this]
    exact S_closed
  contradiction
-- QED

end Furstenberg
